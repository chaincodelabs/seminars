# Some Responses to the Discussion Questions

Q: What is reasoning behind the max inbound and max outbound defaults? For which type of user would they be considered ideal and when might they be optimized?  
A: This max [outbound (8) limit](https://github.com/bitcoin/bitcoin/commit/94cfec07fd302c9ff9b6a80c47418d4fe56596ae) was added to bitcoind in 2010 and [2 block-relay only connections](https://github.com/bitcoin/bitcoin/pull/15759) were added in 2019. While I couldn't find any statistical proofs, it has been generally accepted by Core devs that increasing the limit will introduce some negative side-effects: (a) increased node outgoing bandwith utilization relaying txns, (b) increased node resource usage since each will likely receive identical inv(data) from many more peers, (c) increased network spike when new blocks are released, (d) potentially decreases decentralization as nodes with little processing power get overwhelmed by larger nodes sending data too fast, (e) there are many more non-listening nodes (behind nat) than listening nodes. so inbound connections to listening nodes are scarce. With all these drawbacks, it seems no one is interested in increasing the limit unless you can prove that it will have a net positive impact on txn/block propagation and health of the overall network. The default max inbound (125 - max_outbound) limit is simpler to explain: (a) consumer routers can have issues with too many TCP connections, (b) you can run out of file descriptors on some OS's, (c) higher memory per connection (send/receive buffers + other data). Note: the inbound limit is configurable for larger nodes via `-maxconnections=125` so you can opt-in to higher resource usage. Links: [1](https://github.com/bitcoin/bitcoin/pull/6014#issuecomment-93185470), [2](https://github.com/bitcoin/bitcoin/issues/9217#issuecomment-262825152), [3](https://github.com/bitcoin/bitcoin/pull/4687#discussion_r17206235).

Q: What is the rationale behind the "new"/"tried" table design? Were there any prior inspirations within the field of distributed computing?  
A: Not a "Why" answer, more like "How": New buckets represent potential new peers that we have not yet established contact with. New allows duplicates (each address could show up in up to 4 new buckets) because it treats the same IP coming from different sources differently. Tried buckets represent peers that we have established meaningful contact. Tried table does not allow duplicates, the same IP always hashes to one single bucket, regardless of where that IP came from. Addresses from new could move to tried or be removed completely if its bucket is full. And interestingly, addresses from tried could also move back to new (evicted). This does not completely answer why we have this two-tier table design in the first place, except for perhaps the aforementioned difference in allowing duplicates. See some code [here](https://github.com/bitcoin/bitcoin/pull/787).

Q: How does a fixed set of 4 outbound peers get chosen? In what circumstances would you evict/change them?  
A: Much of the logic is in `net_processing.cpp`. There's a global counter `g_outbound_peers_with_protect_from_disconnect` that increments up to 4. If I read the code correctly, the "protected peers" are automatically added when we process the headers message and see that the peer's best known block is greater than or equal to our current chain tip (this seems to be true even for Initial Block Download - which is a bit strange, given that we still have not yet seen all the headers / the whole chain..). There doesn't seem to be a way for the protected peers to be removed. Not sure if `CNodeState` is serialized to disk / persistent across power cycles or not? If it isn't, then node restart would reset the set of protected peers to empty. See some code [here](https://github.com/bitcoin/bitcoin/blob/master/src/net_processing.cpp#L1755).

Q: What are feeler connections, and when are they used?  
Feeler connections are short-lived connections made to check that a node is alive. They can be useful for:
  - test-before-evict: if one of the peers is considered for eviction from our AddrMan because another peer is mapped to the same slot in the tried table, evict only if this longer-known peer is offline.
  - move node addresses from New to Tried table, so that we have more connectable addresses in our AddrMan.

Note that in the literature ("Eclipse Attacks on Bitcoinâ€™s Peer-to-Peer Network") only the latter feature is referred to as "feeler connections", although in our codebase feeler connections encompass test-before-evict as well. We make these connections approximately every FEELER_INTERVAL: first we resolve previously found collisions if they exist (test-before-evict), otherwise connect to a node from the new table

Q: How does "diffusion" message spreading work and why is it ineffective against de-anonymization?  
A: Diffusion: Instead of using fixed intervals to broadcast and relay INV messages, node now uses a random delay timer. So it picks a neighbor at random AND use a random delay timer per peer, until the tx has been broadcasted / relayed to all reachable peers. Diffusion is still ineffective against deanonymization because despite the random timers, the spreading pattern is still structured/symmetric which betrays the originating source (with good probability). See code [here](https://github.com/bitcoin/bitcoin/commit/5400ef6bcb9d243b2b21697775aa6491115420f3).

Q: Why must transaction unlocking scripts only push numbers to be relayed?  
A: Transaction locking scripts specify the requirements that must be fulfilled to spend a UTXO, and locking scripts generally include placeholders for values that must be provided in the unlocking script. When spending an input, values must be placed into the unlocking script of a transaction, such that any bitcoin node can evaluate the script and determine whether the transaction is authorized to spend the input. The combination of the locking script and the unlocking script in a transaction must result in the "stack" evaluating to a non-zero value for the input to be considered spendable. The only types of values that can exist on the "stack" to be evaluated in transaction execution are numbers. These numbers could represent cryptographic keys, time, or arbitrary values.

Q: What output scripts are 'IsStandard'?  
A: Bitcoin contains standardness checks for a transaction's version, its inputs, and its outputs. Specific to transaction outputs, the standardness rules are:

- The output must [not be a "dust" (IE spam)](https://github.com/bitcoin/bitcoin/blob/fa0074e2d82928016a43ca408717154a1c70a4db/src/policy/policy.cpp#L126) amount
- The output must not be some [unrecognized transaction type](https://github.com/bitcoin/bitcoin/blob/fa0074e2d82928016a43ca408717154a1c70a4db/src/policy/policy.cpp#L58) ([segwit](https://github.com/bitcoin/bitcoin/blob/fa0074e2d82928016a43ca408717154a1c70a4db/src/script/standard.cpp#L144) or [otherwise](https://github.com/bitcoin/bitcoin/blob/fa0074e2d82928016a43ca408717154a1c70a4db/src/script/standard.cpp#L177))
- If the output is "bare multsig" (IE not a P2SH multsig or a P2WSH multsig):
    - `m-of-n` Multisig outputs must follow [these rules](https://github.com/bitcoin/bitcoin/blob/fa0074e2d82928016a43ca408717154a1c70a4db/src/policy/policy.cpp#L60):
        - Must allow at least one `m` key to spend
        - Must have at least one `n` key enabling spending
        - Must have no more than 3 `n` keys
        - Must specify fewer or equal `m` than `n` keys to spend (IE `4-of-3` would not be allowed)
    - The node [must permit](https://github.com/bitcoin/bitcoin/blob/fa0074e2d82928016a43ca408717154a1c70a4db/src/policy/policy.cpp#L123) bare multisig outputs
- If the output is arbitrary data (`NULL_DATA`), the node must accept `NULL_DATA` outputs (currently this is hardcoded to `true` via [`DEFAULT_ACCEPT_DATACARRIER`](https://github.com/bitcoin/bitcoin/blob/bd6af53e1f8ec9d25cedf0bf36c98b99a8d88774/src/script/standard.h#L15)) and the arbitrary data must be below a certain byte size ([source](https://github.com/bitcoin/bitcoin/blob/fa0074e2d82928016a43ca408717154a1c70a4db/src/policy/policy.cpp#L68))
- Across all outputs, [only one](https://github.com/bitcoin/bitcoin/blob/fa0074e2d82928016a43ca408717154a1c70a4db/src/policy/policy.cpp#L133) may contain arbitrary data via `NULL_DATA`

Q: Why must transactions be no less than 82 bytes to be relayed?  
A: This is a mitigation of Merkle tree weakness [CVE-2017-12842](https://bitcointechweekly.com/front/cve-2017-12842-leaf-node-weakness-trusted-merkle-tree-depth-for-safe-tx-inclusion-proofs-without-a-soft-fork/). See [here](https://github.com/bitcoin/bitcoin/pull/11423) and [here](https://github.com/bitcoin/bitcoin/pull/16885).  

Q: Why is the blockheight now encoded in the coinbase transaction?  
A: To force unique coinbase txids. Before encoding the block height into the coinbase, two coinbase transactions could be the same resulting in one txid for two transactions. Learn more [here](https://learnmeabitcoin.com/glossary/txid#footnote-unique-txids) and see the [PR](https://github.com/bitcoin/bitcoin/pull/1526).
