# Some Responses to the Discussion Questions

1. To force unique coinbase txids. Before encoding the block height into the coinbase two coinbase transactions could be the same resulting in one txid for two transactions. Learn more [here](https://learnmeabitcoin.com/glossary/txid#footnote-unique-txids).
2. **Overt**: version-rolling method which is completely transparent in the blockheader of each boosted Bitcoin block. **Covert**: Recalculation of the merkle tree which is easier with small or empty blocks. Learn more [here](https://www.asicboost.com/single-post/2018/03/01/opening-asicboost-for-defensive-use/) and [here](https://bitslog.com/2017/04/10/the-relation-between-segwit-and-asicboost-covert-and-overt/).
3. **Why**: the nonce value in the header field is only 32 bit, which is a trivial nonce space to burn through with any modern miner (say, at 16TH/s), and after overflow updating a nonce in the coinbase needs a (partial) merkle tree recompute, so it's the most efficient way, I guess"" and ""nTime can be used as well, though as that value is in seconds and there's strict requirements on it, there's not that much wiggle room as the 16 extra version bits give"" -- Wladimir J. van der Laan (twitter discussion) Also that it's easier to update the version bits to change the nonce in an ASIC then to change the nonce in the coinbase.
**Side effect**: This caused spurious Unknown block versions being mined"" error messages." Learn more [here](https://github.com/bitcoin/bitcoin/pull/15471).
7. There's a bunch of logic for checking if a transaction is standard, such as number of inputs, if its under the dust threshold, etc. I linked the code for the function on the right (policy.cpp).
Second link is the definition of what sorts of transaction types are considered standard. Learn more [here](https://github.com/bitcoin/bitcoin/blob/master/src/script/standard.h#L59) and [here](https://github.com/bitcoin/bitcoin/blob/master/src/policy/policy.cpp#L80).
8. Looking at the code, I see a minimum of 82 bytes. Code comments state the following as the motivation: A transaction with 1 segwit input and 1 P2WPHK output has non-witness size of 82 bytes. Transactions smaller than this are not relayed to reduce unnecessary malloc overhead. See [here](https://github.com/bitcoin/bitcoin/blob/master/src/policy/policy.h#L26) and [here](https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L599).
9. **What?** The Fast Internet Bitcoin Relay Engine (FIBRE) is is a protocol and implementation designed to relay blocks within a network of nodes with almost no delay beyond the speed of light through fiber.
**How?** FIBRE improves on the design of the Bitcoin Relay Network primarily in two ways: it eliminates latency spikes by sending extra data to compensate for packet loss (UDP and forward-error-correction) and is based on the compression provided by the Compact Block work in Bitcoin Core.
**Why?** Miners want to know ASAP if a new block is found to start mining on it. The previously used TPC is not suitable to relay blocks over long distances with high latency (i.e. around the globe), since TCP needs a round trip for error correction. See [here](http://bitcoinfibre.org/fibre-howto.html).
12. **What?** The block or share witholding attack cause financial harm to a pool operator. A pool miner that solves a block can withhold a valid hash after finding one. The cost to the miner is trivial (from not being awarded the one share) but the cost to the pool is large as the pool loses a chance to earn the block award subsidy + fees.
**Why?** No profit for the withholding miner, only harm to the pool operator.
